<!DOCTYPE html>
<html lang="en">

<head>
	<title>CNC Lock Cracking Robot | Michael Crum | Portfolio</title>

	<!-- seo -->
	<meta name="author" content="Michael Crum">
	<meta name="description" content="A robot designed to efficiently find the combination to any master lock brand combination lock. Programmed bare-metal on the FRDM-KL46Z board using C and assembly. Electronics control board custom made, interfacing with the FRDM-KL46Z through purpose built drivers. Fabricated using a PRUSA I3 MK3S 3D printer and an Epilog Fusion M2 laser cuter.">
	<meta name="keywords" content="portfolio,developer,robotics,personal">

	<!-- display -->
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">

	<!-- icon -->
	<link rel="icon" type="image/png" sizes="32x32" href="../global_assets/icons/favicon-32x32.png" />
	<link rel="icon" type="image/png" sizes="16x16" href="../global_assets/icons/favicon-16x16.png" />

	<!-- stylesheets -->
	<link rel="stylesheet" href="../styles/project_page.css">
	<link rel="stylesheet" href="../styles/highlight/styles/base16/bright.min.css">
	<link rel="stylesheet" href="../styles/katex/katex.min.css">

	<!-- syntax highlighting-->
	<script src="../styles/highlight/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>

	<!-- latex support-->
	<script defer src="../styles/katex/katex.min.js"></script>

	<!-- font -->
	<link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet" />

	<!-- analytics -->
	<script data-goatcounter="https://michael-crum.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>

	<!-- iFrame optimization -->
	<script>
		checkVisibility();
		document.addEventListener("scroll", (event) => {
			checkVisibility();
		});

		function checkVisibility() {
			const frames = document.getElementsByTagName("iframe");
			for (var i = 0; i < frames.length; i++) {
				frame = frames[i];
				if (isInViewport(frame)) {
					frame.style.visibility = "visible";
				} else {
					frame.style.visibility = "hidden";
				}
			}
		}

		function isInViewport(elm) {
			var rect = elm.getBoundingClientRect();
			var viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
			return !(rect.bottom < 0 || rect.top - viewHeight >= 0);
		}
	</script>
</head>

<body>
	<div id="left_pad"></div>
	<aside>
		<a id="back_button" href="../"><img src="../global_assets/icons/back-arrow.svg" alt="back" title="back"></a>
		<h1><a href="..">Michael Crum</a></h1>
		<h4><em>More Projects:</em></h4>
		<nav>
			<ul>
				<li>
	<a href="../string_art_generator">
		<img src="../string_art_generator/assets/snapshot.webp" alt="Generalized String Art Generator">
		<div>
			<p>Generalized String Art Generator</p>
			<em>11.01.2023</em>
		</div>
	</a>
</li>

<li>
	<a href="../fast_robots">
		<img src="../fast_robots/assets/snapshot.webp" alt="Teaching Cheap Robots Expensive Tricks">
		<div>
			<p>Teaching Cheap Robots Expensive Tricks</p>
			<em>5.20.2023</em>
		</div>
	</a>
</li>

<li>
	<a href="../raymarching">
		<img src="../raymarching/assets/snapshot.webp" alt="An Introduction to Ray Marching">
		<div>
			<p>An Introduction to Ray Marching</p>
			<em>3.23.2023</em>
		</div>
	</a>
</li>

<li>
	<a href="../pov_display">
		<img src="../pov_display/assets/snapshot.webp" alt="Holographic POV Display">
		<div>
			<p>Holographic POV Display</p>
			<em>12.16.2022</em>
		</div>
	</a>
</li>

<li>
	<a href="../lock_cracking_robot">
		<img src="../lock_cracking_robot/assets/snapshot.webp" alt="CNC Lock Cracking Robot">
		<div>
			<p>CNC Lock Cracking Robot</p>
			<em>4.12.2022</em>
		</div>
	</a>
</li>

<li>
	<a href="../spinout">
		<img src="../spinout/assets/snapshot.webp" alt="Spinout: A Fully Custom Multiplayer Online Racing Game">
		<div>
			<p>Spinout: A Fully Custom Multiplayer Online Racing Game</p>
			<em>11.23.2021</em>
		</div>
	</a>
</li>

<li>
	<a href="../frc-2020">
		<img src="../frc-2020/assets/snapshot.webp" alt="FRC - Infinite Recharge">
		<div>
			<p>FRC - Infinite Recharge</p>
			<em>3.6.2020</em>
		</div>
	</a>
</li>

<li>
	<a href="../processing_arcade">
		<img src="../processing_arcade/assets/snapshot.webp" alt="Processing Arcade: A Collection of Javascript Games">
		<div>
			<p>Processing Arcade: A Collection of Javascript Games</p>
			<em>8.13.2016</em>
		</div>
	</a>
</li>

			</ul>
		</nav>
		<h3><em>More Bits:</em></h3>
		<nav>
			<ul>
				<li>
	<a href="../attiny1616">
		<img src="../attiny1616/assets/snapshot.webp" alt="Zero to Bare Metal AVR Programming with the ATtiny1616">
		<div>
			<p>Zero to Bare Metal AVR Programming with the ATtiny1616</p>
			<em>11.07.2023</em>
		</div>
	</a>
</li>

<li>
	<a href="../static_page_gen">
		<img src="../static_page_gen/assets/snapshot.webp" alt="Building a 100 Line Static Site Generator">
		<div>
			<p>Building a 100 Line Static Site Generator</p>
			<em>3.30.2023</em>
		</div>
	</a>
</li>

			</ul>
		</nav>
	</aside>
	<article id="article">
		<h1>
			CNC Lock Cracking Robot
		</h1>
		<em class="date">
			4.12.2022
		</em>
		<br>
		<h2>Introduction</h2>
<p>Master Lock combination locks are notoriously easy to crack, to the point that they have become a running joke in the lock picking community. Yet they are still one of the most popular locks ever made, making them a perfect target for an automated cracking tool.</p>
<p>I designed a lock cracking robot for exactly that purpose. The robot exploits design flaws in the locks to reduce the number of combinations from 64,000 down to just 8, then tests them all in around 15 seconds.</p>
<p>The robot is designed using a NEMA 17 stepper motor to rotate the dial, an analog servo to actuate the shackle, the FRDM-KL46Z microcontroller to run the show.</p>
<iframe width="100%" style="aspect-ratio: 9/5" src="https://www.youtube.com/embed/n434a4aqk5E" title="CNC Combo cracker: ECE 3140 Final project" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<blockquote>
<h5>click on the thumbnail to watch the video</h5>
</blockquote>
<h2>System Overview</h2>
<h3>Hardware</h3>
<p>The robot's body is made from clear laser cut acrylic, housing the electronics that make it work. A NEMA 17 stepper motor rotates the dial and an analog feedback servo is used to pull on the shackle and determine if the lock has been opened. All of the electronics are driven through a custom circuit board powered by a wall outlet.</p>
<h3>Software</h3>
<p>I wrote custom stepper and analog servo drivers to control the robot, as well a library for using the buttons and capacitive touch slider on the FRDM-KL46Z to control a LCD based UI. I also implemented the cracking algorithm, which requires the user to find and enter three binding points on the lock. Using exploits in the master lock's design, the number of combinations is dropped down to 8, which can be attempted in under 30 seconds.</p>
<h2>Technical Description</h2>
<h3>Hardware</h3>
<p>The main drivers of the robot are the NEMA 17 stepper motor and the analog feedback servo motor.</p>
<p>The quintessential requirement of combination cracking is turning the dial. For this job I chose a stepper motor. Stepper motors are easy to control, fast, and accurate. Steppers are controlled in discrete &quot;steps&quot;, each constituting a consistent percentage of a rotation. For the stepper I chose, this was 200 steps per rotation. Given that a master lock has 40 positions, this gives a resolution of 5 steps per number on the lock.</p>
<p>To open the shackle, and I needed a high torque motor that I could control positionally. A standard hobby servo meets these requirements perfectly, but I also needed to determine if the shackle did in fact open. An analog feedback servo offers an feedback signal reporting the actual position of the arm, allowing me to check if the servo was able to pull the shackle out of the lock.</p>
<p>Once I decided on the components I wanted to use, I was time to build the body of the robot. I used a CAD program named OnShape to design the parts. They were then either 3D printed in PLA or laser cut from 3/16&quot; acrylic and assembled using screws. The end result is a clean transparent look with red and pink highlights.</p>
<p><img src="./assets/ca.webp" alt="CAD for the robot"></p>
<p>Next, I needed to power and control the motors. A custom circuit board to provide a central source of power and control.</p>
<p><img src="./assets/circuitboard.webp" alt="The circuit board"></p>
<p>Power is supplied from a 12V 2A wall adapter, which provides direct power to the stepper motor. I also used a 6V step down to provide power for the FRDM-KL46Z and the servo motor. Due to the nature of DC motors, voltage spikes are unavoidable during operation. To prevent these spikes from disrupting the power to the FRDM-KL46Z, I added a 100 microfarad capacitor across the supply lines. To control the stepper motor, I used Allegro’s A4988 stepper driver. The driver is capable of powering the 2A stepper at full power, and supplies an simple control scheme for direction and position. Finally, I routed all of the signal, power, and ground connections to a central bus that is broken out to connect to the FRDM-KL46Z with minimal lose wires.</p>
<h3>Software</h3>
<p>Before I could work on the cracking algorithm, I needed to write drivers for my peripherals.</p>
<p>The A4988 stepper driver accepts three inputs for control. These are ENABLE, DIRECTION, and STEP. ENABLE is self explanatory, and I use it to activate and deactivate the stepper. DIRECTION controls the direction of rotation, and STEP converts each low-high transition into a step of the motor. Because the stepper's operation is never interrupted by another routine, I chose to generate the low-high pulses using simple for-loop waits. I also implemented functions to go to certain positions, guided by an accumulator to keep track of the current location of the motor. This will be useful later to hit specific numbers in a combination.</p>
<p>Next is control of the servo. Servo motors are controlled with PWM (pulse width modulation). My servo uses a frequency of 50 Hz, and pulses that range from 500 to 2000 microseconds. The width of the pulse decides the location of the servo. The FRDM-KL46Z includes a dedicated PWM peripheral called the TPM (timer / PWM module). I followed the chapter in the reference manual to configure the correct registers, then used a digital logic analyzer to verify that my pulses were the correct size. Shown bellow is a 500 microsecond pulse generated by the TPM.</p>
<p><img src="./assets/pwm_pulse_scale.webp" alt="A 500 microsecond pulse"></p>
<p>I then mapped servo positions to their pulse width. The servo also needed to know where it was, so it can check if it was successful in opening the lock. I chose a servo with an analog feedback wire, which I read using the ADC. Finally, I wrote a driver to combine all this functionality into one interface.</p>
<p>Now I could finally get to cracking. I wrote and tested a routine to enter a combo, attempt to lift the shackle, and return if the lock opened or not. When this worked, I moved on to generating combinations to feed it. The naïve approach was simply three nested for-loops iterating over all 64,000 possible combinations. I also implemented an advanced approach, which requires some prep by the user. The steps are as follows:</p>
<p>Hold the lock and pull up on the shackle. While pulling up on the shackle, move the dial towards 10. The dial should get stuck in a groove, but can spin slightly within it. If the groove goes between two whole numbers, ignore it and continue towards 10. If it goes across a whole number. Enter that number into the FRDM-KL46Z, and press the right button. Continue towards 10 until you find a second such groove, and enter this into the  FRDM-KL46Z as well.</p>
<p>Now, loosen pressure on the dial until it can barely spin. Spin the dial repeatedly, looking for a point of resistance. Make sure the point is the same on each turn. Enter this number into the FRDM-KL46Z, and press the right button again.</p>
<p>The point of resistance comes from a manufacturing flaw in the third combination disk, which allows us to find the first number simply by adding 5. The combination is further governed by the following rules:</p>
<p>The 1st number is congruent to the first groove mod 10.</p>
<p>The 2nd number is congruent to the second groove mod 10.</p>
<p>The 1st and 3rd numbers are congruent mod 4.</p>
<p>The 2nd number + 2 and the 3rd number are congruent mod 4.</p>
<p>The 2nd and 3rd number are not within two in either direction.</p>
<p>Using the collected info and these rules, we can narrow the potential combinations from 64,000 down to just eight. Below is the code for the advanced crack:</p>
<pre><code class="language-cpp">void advanced_crack(int lck_one, int lck_two, int resist){
	int one, two, three;

	one = resist + 5;

	for(two = 0; two &lt; 40; two++){
		if(one == two) continue;
		for(three = 0; three &lt; 40; three++){
			if(two == three) continue;
			if(three % 10 != lck_one &amp;&amp; three % 10 != lck_two) continue;
			if(three % 4 != one % 4) continue;
			if((two + 2) % 4 != three % 4) continue;
			if(three - two &lt;= 2 &amp;&amp; three - two &gt;= -2) continue;
			display_combo(one, two, three);
			if(try_combo(one, two, three)){
				return; //Unlocked!
			}

			if(three != 0){
				go_to_number_right(0);
			}

		}
	}
}
</code></pre>
<p>I implemented these rules by using nested for loops just as before, and using continue statements to skip invalid combos.</p>
<p>The last step was to make the UI. I chose to use the LCD to display info, and the capacitive touch slider paired with the buttons for control. This avoided any additional hardware.</p>
<p>I used the TA provided library to control the LCD, touch slider, and buttons. I modified them to avoid using the MCUXpresso clock controls (clock_config.h), as I found them to cause side-effects that broke other code.</p>
<p>The UI is used to enter found positions for advanced mode, and to display the current combination attempt while cracking. To enter a number, tap the sides of the slider to go up or down. Use the right button to confirm the selection, and hit the left button to begin cracking.</p>
<p>Entering the positions happens before cracking, so I could use polling without interrupting the stepper driver. I poll both the button and the touch slider and update the relevant variables accordingly.</p>
<p>Once cracking begins, I need to display the combo without interrupting the stepper driver. Additionally, the LCD can only display 4 digits which is not enough for a full combo. I chose to use PIT interrupts to solve this issue, and cycle through the numbers to display the full combo. The last number is followed by a decimal, so that the order of the numbers is obvious.</p>
<p>When the lock is opened, the LCD continues to display the combo so the user will know what the combination was.</p>
<h2>Testing</h2>
<p>To make sure that my design was feasible, I tested each individual component as I built the system. The stepper motor and driver are the most crucial part of the bot, so they came first. I ensured accuracy by commanding a variety of different steps and ensuring that I could return back to a consistent zero position each time. With the stepper working, I was also able to try my first cracking attempt, where I already knew the combo and made the stepper go to those positions. When that worked, I knew that it was sufficiently accurate for the job.</p>
<p>Adding the servo into the mix caused some issues. The first issue was with current draw. When stalled, I estimated that the servo could draw 1 A of current. When tested, it was drawing closer to 1.5 A, and causing the FRDM-KL46Z to lose power. I fixed this by adding capacitance across the power supply lines to stop voltage spikes, and switching to a power supply rated for higher amperage.</p>
<p>A second issue was the strength of the servo. I positioned the servo close to the stepper, with a fairly short arm to reach out and lift the shackle. I underestimated the amount of force required, so the shackle would sometimes not open. To remedy this, I added a spring to assist the servo in its upward motion.</p>
<p>Finally I used stress testing to test the rest of the system. Cracking a master lock with no prior knowledge takes upwards of 64,000 attempts, which takes 36 hours straight. This served as the ultimate stress test, and I left it running for a day and a half. The system managed to open the lock after only 20 hours, and displayed the correct combination when finished.</p>
<h2>Further documentation</h2>
<p><a href="https://github.com/usedhondacivic/ECE-3140-Lock-Cracking-Robot">GitHub Repository</a></p>
<p><a href="https://cad.onshape.com/documents/05aac48a55782d85d245cccd/w/e7e86bb57175dc86d1433f3c/e/72aafb165d7a97047a56eae0?renderMode=0&amp;uiState=6288668d62c0193394baf0e8">CAD document</a></p>
<h2>Additional Resources Used</h2>
<p><a href="https://samy.pl/master/master.html">Samy Kamkar's fantastic build</a></p>
<p>Thanks to the Cornell Maker Club for letting me use their equipment and space</p>
<p>Thanks to the RPL for their laser cutting service</p>
<p><a href="https://www.omc-stepperonline.com/nema-17-bipolar-59ncm-84oz-in-2a-42x48mm-4-wires-w-1m-cable-connector-17hs19-2004s1">NEMA 17 Stepper Motor</a></p>
<p><a href="https://www.adafruit.com/product/1404">Analog feedback servo</a></p>

	</article>
	<div id="right_pad"></div>
</body>

</html>
