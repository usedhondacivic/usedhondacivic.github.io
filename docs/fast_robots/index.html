<!DOCTYPE html>
<html lang="en">

<head>
    <title>Teaching Cheap Robots Expensive Tricks | Michael Crum | Portfolio</title>

    <!-- seo -->
    <meta name="author" content="Michael Crum">
    <meta name="description" content="Using an inexpensive toy car, some basic sensors, and a little software wizardry, I created a robot capable of mapping, localization, and path planning. Read about my experiences with sensor fusion, modeling dynamics, PID control, Bayesian estimation, wireless communication, and more... and it can also do stunts!">
    <meta name="keywords" content="portfolio,developer,robotics,personal">

    <!-- display -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    <!-- icon -->
    <link rel="icon" type="image/png" sizes="32x32" href="../global_assets/icons/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="../global_assets/icons/favicon-16x16.png" />

    <!-- stylesheets -->
    <link rel="stylesheet" href="../styles/project_page.css">
    <link rel="stylesheet" href="../styles/highlight/styles/base16/bright.min.css">
    <link rel="stylesheet" href="../styles/katex/katex.min.css">

    <!-- syntax highlighting-->
    <script src="../styles/highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <!-- latex support-->
    <script defer src="../styles/katex/katex.min.js"></script>

    <!-- font -->
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet" />

    <!-- iFrame optimization -->
    <script>
        checkVisibility();
        document.addEventListener("scroll", (event) => {
            checkVisibility();
        });

        function checkVisibility() {
            const frames = document.getElementsByTagName("iframe");
            for (var i = 0; i < frames.length; i++) {
                frame = frames[i];
                if (isInViewport(frame)) {
                    frame.style.visibility = "visible";
                } else {
                    frame.style.visibility = "hidden";
                }
            }
        }

        function isInViewport(elm) {
            var rect = elm.getBoundingClientRect();
            var viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
            return !(rect.bottom < 0 || rect.top - viewHeight >= 0);
        }
    </script>
</head>

<body>
    <div id="left_pad"></div>
    <aside>
        <h1><a href="..">Michael Crum</a></h1>
        <h3><em>More Projects:</em></h3>
        <nav>
            <ul>
                <li>
    <a href="../fast_robots">
        <img src="../fast_robots/assets/snapshot.webp" alt="Teaching Cheap Robots Expensive Tricks">
        <div>
            <p>Teaching Cheap Robots Expensive Tricks</p>
            <em> 5.4.2023</em>
        </div>
    </a>
</li>
<li>
    <a href="../raymarching">
        <img src="../raymarching/assets/snapshot.webp" alt="An Introduction to Ray Marching">
        <div>
            <p>An Introduction to Ray Marching</p>
            <em> 3.23.2023</em>
        </div>
    </a>
</li>
<li>
    <a href="../pov_display">
        <img src="../pov_display/assets/snapshot.webp" alt="Holographic POV Display">
        <div>
            <p>Holographic POV Display</p>
            <em> 12.16.2022</em>
        </div>
    </a>
</li>
<li>
    <a href="../lock_cracking_robot">
        <img src="../lock_cracking_robot/assets/snapshot.webp" alt="CNC Lock Cracking Robot">
        <div>
            <p>CNC Lock Cracking Robot</p>
            <em> 4.12.2022</em>
        </div>
    </a>
</li>
<li>
    <a href="../spinout">
        <img src="../spinout/assets/snapshot.webp" alt="Spinout: A Scratch-Built Multiplayer Online Racing Game">
        <div>
            <p>Spinout: A Scratch-Built Multiplayer Online Racing Game</p>
            <em> 11.23.2021</em>
        </div>
    </a>
</li>
<li>
    <a href="../frc-2020">
        <img src="../frc-2020/assets/snapshot.webp" alt="FRC - Infinite Recharge">
        <div>
            <p>FRC - Infinite Recharge</p>
            <em> 3.6.2020</em>
        </div>
    </a>
</li>
<li>
    <a href="../processing_arcade">
        <img src="../processing_arcade/assets/snapshot.webp" alt="Processing Arcade: A Collection of Javascript Games">
        <div>
            <p>Processing Arcade: A Collection of Javascript Games</p>
            <em> 8.13.2016</em>
        </div>
    </a>
</li>
            </ul>
        </nav>
        <h3><em>More Bits:</em></h3>
        <nav>
            <ul>
                <li>
    <a href="../static_page_gen">
        <img src="../static_page_gen/assets/snapshot.webp" alt="Building a 100 Line Static Site Generator">
        <div>
            <p>Building a 100 Line Static Site Generator</p>
            <em> 3.30.2023</em>
        </div>
    </a>
</li>
            </ul>
        </nav>
    </aside>
    <article id="article">
        <h1>
            Teaching Cheap Robots Expensive Tricks
        </h1>
        <em class="date">
            5.4.2023
        </em>
        <br>
        <h2>WIP</h2>
<p>This write-up is under construction! Come back soon for more :)</p>
<h2>Introduction</h2>
<p>In robotics, we often find ourselves attempting to do more with less. Computers, actuators, and sensors are never as fast, strong, or accurate as we would like, so we need to use very clever design to make them achieve peak performance. The purpose of this project was taking this idea to the extreme: could I get reasonable results using the absolute bare minimum in hardware. And no, this totally had nothing to do with being a broke college student.</p>
<p>The platform I used for this robot is a cheap RC car from Amazon, designed for doing stunts. I'll first cover the physical and electrical modifications I made to the car, then get into the fun applications and the software algorithms that enabled them.</p>
<p>Its worth noting that this article is a massively abbreviated version of my <a href="https://michael-crum.com/FAST-ROBOTS-2023/intro/">full build log</a>, and primarily serves as an entertaining overview. For all of the real technical details, you should check out the full build log (linked above) and <a href="https://github.com/usedhondacivic/FAST-ROBOTS-2023">the source code</a>.</p>
<h2>Brain Surgery on a Car</h2>
<p>A toy car is electrically very simple. The one I'm using has one motor per side, connected to a microcontroller that converts information from the remote control into speed commands. For complicated processing and communication, the integrated controller is totally inadequate. I used the <a href="https://www.sparkfun.com/products/15443">SparkFun Artemis Nano</a> microcontroller as a replacement, which boasts a 48Mhz clock, 1MB flash, 384k RAM, and built in Bluetooth. This gives me plenty of clock cycles to play with and greatly simplifies my communication solution.</p>
<p>A microcontoller is nothing with some peripherals, so I tricked out the car with some more gear. To control the motors, I used two <a href="https://www.digikey.com/en/products/detail/pololu-corporation/2130/10450426">dual channel motor drivers</a>, using two channels per motor to get 2.4 A output per motor. For sensing, I went for a <a href="https://www.mouser.com/ProductDetail/SparkFun/SEN-15335?qs=uwxL4vQweFMcls1MYZT00A%3D%3D">9 Degree of Freedom IMU</a> and two <a href="https://www.pololu.com/product/3415">Time of Flight sensors</a> rated for 4 meters of range.</p>
<p>The sensor peripherals all communicate over I2C, and I used the SparkFun QWIIC connector system that is built into the Artemis. QWIIC is just a dedicated connector and cables for I2C, but makes prototyping much quicker and more reliable.</p>
<p>After cutting the cables and removing the included control hardware, I soldered the motor leads into my motor drivers and wired all the peripherals into the artemis. Two 3.7V 850mAh LiPo batteries provide power, one dedicated to the motors and the other to the control electronics. Isolating the power source minimizes electromagnetic interference between the motors and sensors, a common issue when using brushed (or really any) motors.</p>
<p><img src="./assets/car_electronics.webp" alt="The car's electronics installed"></p>
<blockquote>
<p><em>The car's electronics installed, featuring my scribbled labels</em></p>
</blockquote>
<p>I also designed and 3D printed a guard to protect the ToF sensors from inevitable crashes.</p>
<p><img src="./assets/tof_guard.webp" alt="The tof guard"></p>
<blockquote>
<p><em>The guard for the ToF sensors</em></p>
</blockquote>
<p>All together this package comes in at well under $100.</p>
<h2>Software Basis</h2>
<p>I'll get to the cool applications soon, but first I want to cover some basic software techniques that enable the more complicated stuff that's coming up.</p>
<h3>Software Stack</h3>
<p>The Artemis Nano is compatible with the Arduino Core, allowing use of a wide variety of libraries and drivers. The ToF sensors and IMU have drivers from their vendors, and the motor drivers are simple to interface with using PWM. Similarly, the Bluetooth Low Energy (BLE) module on the Artemis is supported by an Arduino Core library.</p>
<p>The Artemis is a wonderful little powerhouse, but for computationally expensive tasks it is just not fast enough. I instead offload data to my laptop over BLE, compute the relevant values using Python, then send them back. For Python-side BLE communication I used the Bleak module. The other Python heavy-lifters are the usual suspects, namely Numpy for computation and Matplotlib for plotting.</p>
<h3>Sensor Fusion</h3>
<p>On the best of days, data from cheap sensors is noisy and full of errors. On a bad day, say when placed right next to two brushed EMI generating nightmares, they can become downright unusable.</p>
<p>To combat the noise associated with individual readings, roboticist use a technique called sensor fusion. Sensor fusion is combing two or more readings to generate a more accurate final signal. A classic example (and the one I implemented) is combining accelerometer and gyroscope readings to get a measure of rotation.</p>
<p>First off, how do you measure rotation with an accelerometer? Earths gravitational field causes a downward acceleration of <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9.81</mn><mi>m</mi><mi mathvariant="normal">/</mi><msup><mi>s</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">9.81 m/s^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">9.81</span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></eq> on all objects, which is also measured by the accelerometer. By determining the direction of gravitational acceleration relative to the accelerometer you can find the accelerometers pitch and yaw.</p>
<p>Due to their design, accelerometers are plagued by high frequency noise leading to unreliable point readings. On the other end of the spectrum, gyroscopes have almost no noise but drift slowly over time. We can think of this as extremely low frequency noise, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq>. What we really want is our signal to have the correct 'center' from the accelerometer combined with the low noise from the gyroscope.</p>
<p>The filter that gives this effect is called a complementary filter. The basic operating principle is applying a high-pass filter to the gyroscope (allowing for sudden changes but filtering out drift over time) and a low-pass filter to the accelerometer (maintaining the true center relative to gravity) and summing them.</p>
<p>Below is the code for implementing such a filter:</p>
<pre><code class="language-cpp">// Time since last read
float dt = (float)(millis() - sensor_readings.gyro.stamp) / 1000.0; 

// Compute the accel roll and pitch from gravitational acceleration
float roll = atan2(sensor_readings.accel.y, sensor_readings.accel.z) * (180.0 / 3.14);
float pitch = atan2(sensor_readings.accel.x, sensor_readings.accel.z) * (180.0 / 3.14);

// Mathematically equivalent to low passing accel and high passing gyro
float gyro_favor = 0.98;
pose.rot.x = (gyro_favor) * (pose.rot.x + myICM.gyrX() * dt) + (1.00 - gyro_favor) * (roll);
pose.rot.y = (gyro_favor) * (pose.rot.y - myICM.gyrY() * dt) + (1.00 - gyro_favor) * (pitch);
// We cannot compute yaw from accel because the z axis is parallel to gravity
pose.rot.z = sensor_readings.gyro.z;
</code></pre>
<p><img src="./assets/complementary.webp" alt="Graph showing the complimentary filter output"></p>
<p>As you can see from the graph, the accelerometer is noisy (blue and orange) and the gyro drifts (dark green and mint), yet the complimentary output rejects noise while staying centered on the accelerometer data (purple and red).</p>
<h3>PID Control</h3>
<h3>Wireless Communication and Logging</h3>
<h2>Mapping the Surroundings</h2>
<p>Ok now we're ready for the real juicy stuff. How about mapping out a room?</p>
<p><img src="./assets/room_post_tweek.webp" alt="The generated map of the room"></p>
<h2>Localization and Navigation</h2>
<p>Now that we have a map of our room, can we use it to figure out where the robot is? This is a common problem in robotics, known as localization.</p>
<h3>The Bayes Filter</h3>
<h2>Using Kalman Filters for Optimized Drifting</h2>
<h2>Resources and Special Thanks</h2>
<p>See a full listing of the code <a href="https://github.com/usedhondacivic/FAST-ROBOTS-2023">here</a>.</p>
<p>This article is a massively abbreviated version of my <a href="https://michael-crum.com/FAST-ROBOTS-2023/intro/">full build log</a>. Check that out if you want any of the specifics.</p>
<p>This robot was developed as part of ECE 4160: Fast Robots at Cornell University. My work builds off of course starter code and also of the work from past students. You can find all of their pages <a href="https://cei-lab.github.io/FastRobots-2023/StudentPages.html">here</a>, and I am so grateful for their help. Special thanks to Professor Kirstin Petersen for running a fantastic class.</p>

    </article>
    <div id="right_pad"></div>
</body>

</html>