<!DOCTYPE html>
<html lang="en">

<head>
    <title>An Introduction to Ray Marching | Michael Crum's Portfolio</title>

    <!-- seo -->
    <meta name="author" content="Michael Crum">
    <meta name="description" content="An introduction to the wonders of the ray marching algorithm. Ray marching enables performant real time renderings of fractals, infinite collections of objects, and more. Featuring interactive demos and mesmerizing visualizations.">
    <meta name="keywords" content="portfolio,developer,robotics,personal">

    <!-- display -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- icon -->
    <link rel="icon" type="image/png" sizes="32x32" href="../global_assets/icons/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="../global_assets/icons/favicon-16x16.png" />

    <!-- stylesheets -->
    <link rel="stylesheet" href="../styles/project_page.css">
    <link rel="stylesheet" href="../styles/highlight/styles/base16/bright.min.css">
    <link rel="stylesheet" href="../styles/katex/katex.min.css">

    <!-- syntax highlighting-->
    <script src="../styles/highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <!-- latex support-->
    <script defer src="../styles/katex/katex.min.js"></script>

    <!-- font -->
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet" />

    <!-- Matomo analytics-->
    <script>
        var _paq = window._paq = window._paq || [];
        /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
        _paq.push(['trackPageView']);
        _paq.push(['enableLinkTracking']);
        (function () {
            var u = "https://michaelcrum.matomo.cloud/";
            _paq.push(['setTrackerUrl', u + 'matomo.php']);
            _paq.push(['setSiteId', '1']);
            var d = document, g = d.createElement('script'), s = d.getElementsByTagName('script')[0];
            g.async = true; g.src = '//cdn.matomo.cloud/michaelcrum.matomo.cloud/matomo.js'; s.parentNode.insertBefore(g, s);
        })();
    </script>
</head>

<body>
    <div id="left_pad"></div>
    <aside>
        <h1><a href="..">Michael Crum</a></h1>
        <h3><em>More Projects:</em></h3>
        <nav>
            <ul>
                <li>
    <a href="../raymarching">
        <img src="../raymarching/assets/snapshot.webp" alt="An Introduction to Ray Marching">
        <div>
            <p>An Introduction to Ray Marching</p>
            <em> 3.23.2023</em>
        </div>
    </a>
</li>
<li>
    <a href="../pov_display">
        <img src="../pov_display/assets/snapshot.webp" alt="Holographic POV Display">
        <div>
            <p>Holographic POV Display</p>
            <em> 12.16.2022</em>
        </div>
    </a>
</li>
<li>
    <a href="../lock_cracking_robot">
        <img src="../lock_cracking_robot/assets/snapshot.webp" alt="CNC Lock Cracking Robot">
        <div>
            <p>CNC Lock Cracking Robot</p>
            <em> 4.12.2022</em>
        </div>
    </a>
</li>
<li>
    <a href="../spinout">
        <img src="../spinout/assets/snapshot.webp" alt="Spinout: A Scratch-Built Multiplayer Online Racing Game">
        <div>
            <p>Spinout: A Scratch-Built Multiplayer Online Racing Game</p>
            <em> 11.23.2021</em>
        </div>
    </a>
</li>
<li>
    <a href="../frc-2020">
        <img src="../frc-2020/assets/snapshot.webp" alt="FRC - Infinite Recharge">
        <div>
            <p>FRC - Infinite Recharge</p>
            <em> 3.6.2020</em>
        </div>
    </a>
</li>
<li>
    <a href="../processing_arcade">
        <img src="../processing_arcade/assets/snapshot.webp" alt="Processing Arcade: A Collection of Javascript Games">
        <div>
            <p>Processing Arcade: A Collection of Javascript Games</p>
            <em> 8.13.2016</em>
        </div>
    </a>
</li>
            </ul>
        </nav>
    </aside>
    <article id="article">
        <h1>
            An Introduction to Ray Marching
        </h1>
        <em class="date">
            3.23.2023
        </em>
        <br>
        <p>This write up is under construction, come back soon for more :)
See the code here: <a href="https://github.com/usedhondacivic/ThreeJS-Raymarcher">https://github.com/usedhondacivic/ThreeJS-Raymarcher</a></p>
<p><em>Warning: Some demos on this page are graphically demanding. I recommend enabling GPU acceleration for your web browser for the best experience.</em></p>
<iframe src="https://michael-crum.com/ThreeJS-Raymarcher/mandlebulb" title="Raymarching Demo"></iframe>
<blockquote>
<p><em>Click and drag to rotate, scroll to zoom, right click to pan.</em></p>
</blockquote>
<blockquote>
<p><a href="https://michael-crum.com/ThreeJS-Raymarcher/mandlebulb">See demo full screen</a></p>
</blockquote>
<h2>What is Ray Marching?</h2>
<p>You might be familiar with ray tracing, ray marchingâ€™s better known cousin. Ray tracing is a rendering process that uses math to simulate light bouncing around a scene before entering the camera. By computing the path light takes to enter each pixel of the screen, we can determine the color of that pixel based on material properties and lighting. For a simple one file demo of ray tracing, check out <a href="https://michael-crum.com/Js-Raycaster-V1/">my Javascript implementation</a>.</p>
<p>Ray tracing gives stunning results, but is exceptionally computationally expensive. The main issue lies in the time complexity of ray intersection math, which must be performed many times for each pixel.</p>
<p>Ray marching follows the same concept as ray tracing (following rays through space), but lowers the load through some computational cleverness.</p>
<p>I'll first walk through the theoretical basis for ray marching before finishing the article talking about my implementation.</p>
<h3>Signed Distance Fields (SDFs)</h3>
<p>If computing exact ray-world intersections is too costly, what are our options? Ray marching uses an iterative approach based on Signed Distance Fields (SDFs). Instead of computing an exact intersection, the ray marching algorithm queries the lowest distance between a point and any location on an object. Outside of the object this value is &gt; 0, inside it is &lt; 0, and it is equal to 0 on the border.</p>
<img style="width: 100%; height: auto; max-height: none" alt="An example of signed distance fields" src="./assets/2d_sdf.webp">
<blockquote>
<p><em>An example of signed distance fields for various shapes</em></p>
</blockquote>
<p>Once we know the minimum distance to an object, we can safely step along any ray by that amount and not risk intersecting it. Stepping along the ray yields a new point, from which we can find a new minimum distance, step along the ray once more, and repeat.</p>
<p>The demo below shows the ray marching process for one ray sweeping a 2D scene. Each blue dot represents the end of one &quot;step&quot;, and each ring shows the minimum distance from that point to the scene. Once the distance to the scene is below a threshold, we say we have hit the object and return.</p>
<iframe src="https://michael-crum.com/ThreeJS-Raymarcher/2d_demo.html" title="2D Demo"></iframe>
<blockquote>
<p><a href="https://michael-crum.com/ThreeJS-Raymarcher/2d_demo.html">See demo full screen</a></p>
</blockquote>
<p>SDFs are remarkably efficient, even for many shapes that appear complicated at first glance. Check out <a href="https://iquilezles.org/articles/distfunctions/">Inigo Quilez's site</a> giving SDFs for a huge number of primitives.</p>
<h3>Combining SDFs</h3>
<p>One useful feature of SDF's is how simple they are to combine. The simplest operation is a union, which represents the area inside of either of two shapes. We can find the union of two SDF's by taking the minimum of their two distance fields. This makes sense intuitively as we only care about the minimum distance to any object in the scene.</p>
<pre><code class="language-js">function union(x,y){
    return min(rectangle.sdf(x, y), circle.sdf(x, y))
}
</code></pre>
<p>We can also find the intersection of two shapes, defined as the shared area or overlap. In terms of SDFs, we want the area where the SDF of both shapes is &lt; 0. We can find this by taking the max of the two.</p>
<pre><code class="language-js">function intersect(x,y){
    return max(rectangle.sdf(x, y), circle.sdf(x, y));
}
</code></pre>
<p>Finally, we can subtract one shape from another. This comes curtesy of the &quot;signed&quot; part of SDF. A signed distance field is positive outside the shape and negative inside of the shape. By negating the SDF of a shape we can turn it inside out. Taking the intersection of an inside-out shape with another primitive is equivalent to subtracting the first from the second.</p>
<pre><code class="language-js">function subtract(x,y){
    return max(rectangle.sdf(x, y), -circle.sdf(x, y));
}
</code></pre>
<p>You can see all three operations in the demo below.</p>
<iframe src="https://michael-crum.com/ThreeJS-Raymarcher/2d_demo_combining.html" title="2D Demo"></iframe>
<blockquote>
<p><a href="https://michael-crum.com/ThreeJS-Raymarcher/2d_demo_combining.html">See demo full screen</a></p>
</blockquote>
<p>Another popular and immensely satisfying method is to interpolate between SDFs. This gives the effect of melting the primitives together, and is called a smooth union.</p>
<iframe src="https://michael-crum.com/ThreeJS-Raymarcher/2d_interp.html" title="2D Demo"></iframe>
<blockquote>
<p><a href="https://michael-crum.com/ThreeJS-Raymarcher/2d_interp.html">See demo full screen</a></p>
</blockquote>
<p>The code to achieve a smooth union is simple and shown below (courtesy of <a href="https://iquilezles.org/articles/smin/">Inigo Quilez</a>).</p>
<pre><code class="language-cpp">float opSmoothUnion( float d1, float d2, float k ) {
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h); 
}
</code></pre>
<p>This implementation is a polynomial interpolation, with the &quot;roundness&quot; of the union controlled by factor k.</p>
<p>This also works in 3D of course, as shown below.</p>
<p><em>insert demo</em></p>
<h3>Infinite Repetition</h3>
<p>With a ray tracer, intersections with each primitive in the scene must be independently calculated. This scales poorly with dense scenes (ie a field of blades of grass). With ray marching this problem can be trivialized using domain repetition.</p>
<p>Each step of the ray marching process calculates the distance to the scene from some point, lets call it <code class="language-clike">(x,y)</code>. In the language of SDF's, &quot;repeating a shape&quot; really means that the SDF of the shape is the same in two regions. A simple way of doing this is using the modulo operation. Replacing <code class="language-clike">(x,y)</code> with <code class="language-clike">(x % 5,y % 5)</code> causes the domain of the SDF to repeat every 5 units in the x and y direction, replicating the SDF infinitely. Modulo is computationally cheap, so these shapes come only at the cost of the increase of ray marching steps.</p>
<p><em>insert demo</em></p>
<h3>Ambient Occlusion and Glow</h3>
<p>Ambient occlusion refers to the effect that ambient light has on the shading of a scene. Parts of a scene that are more exposed (less occluded) tend to get brighter due to light bounced from other objects. Similarly, details and crevices are less exposed (more occluded) and therefore get less ambient lighting. Calculating the reflections of ambient light in the scene is extremely expensive using ray tracing methods, but ray marching offers a computationally &quot;free&quot; alternative. We are already keeping track of the number of iterations the ray takes to march to the object, and it turns out this number is a good estimate of the occlusion of the pixel. A higher number of iterations means that the ray passed closely by objects during its travel. We can use this as a metric of occlusion while shading to get a remarkably realistic approximation of &quot;true&quot; ambient occlusion.</p>
<p><em>insert demo</em></p>
<h3>Calculating Normals</h3>
<p>Suppose we want to render a light in our scene. Using ray marching we can calculate the point <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> on the scene that a ray of light hits, but for a realistic effect we also need to know which way it's going to bounce. If we know what direction the surface is facing at point <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>, we can use simple geometry to determine the angle of reflection, but how do we calculate the direction of the surface?</p>
<p>If you've gotten this far in the article you probably know that the &quot;surface direction&quot; I'm referring to is formally known as a normal vector, and is defined as a vector orthogonal to the scene at a point.</p>
<p>You can also think of the normal vector as the direction you travel to increase your distance from the surface as quickly as possible. This interpretation is very convenient when working with SDF's because it implies that the gradient of the SDF is normal to the scene. For those unfamiliar with multi-variable calculus, the gradient of a function is the multi-dimensional analog of the derivative. It is a vector quantity who's value in each dimension is the rate of change of the function with respect to that direction. We can use finite differences to cheaply calculate the gradient, then use that for our lighting calculations.</p>
<p><em>insert code snippet</em></p>
<p><em>insert graphics demo</em></p>
<p>You may have noticed that this method assumes nothing about the contents of the scene. Because of it's generality this lighting will work on any subject, no matter how complex.</p>
<h3>Fractal Distance Fields</h3>
<p>Many fractals have efficient approximations to their distance fields, allowing them to be rendered in real time. The derivation is beyond the scope of this article (see the references below for more info), but the results are too mesmerizing to not feature in this writeup.</p>
<p><em>insert demo</em></p>
<p>We can also generate our own fractals through clever use of domain repetition and transformations of SDFs.</p>
<p><em>insert demo</em></p>
<h2>My Implementation</h2>
<p>So all of that theory is cool, but how do we actually implement it? You may have noticed that each pixel on the screen is computed separately from every other pixel, so the most performant implementation would calculate them all concurrently. Luckily, modern hardware is highly optimized for exactly this operation. You have probably heard of the Graphics Processing Unit (GPU), a part of your computer who's sole job is to run huge parallel processing loads quickly. Using the GPU to aid rendering is known as hardware accelerated rendering, and it enables real-time rendering of remarkably complicated scenes.</p>
<h3>WebGL and Shaders</h3>
<p>WebGL is a widely used API for interfacing with the GPU, and the one I used for my experiments. It is a brother of OpenGL, but focused on browser based uses. The inner workings of WebGL are convoluted and worthy of a whole other article, so I will just give a surface level summary here. The programs we use to interface with the GPU are called shaders, and come in two primary types.</p>
<p>The first is a vertex shader. A vertex shader takes the vertices of the geometry on the scene and is responsible for adding effects to them. This is often converting them from 3D world space to 2D screen space, but can theoretically be any effect you want.</p>
<p>The second is a fragment shader. After the vertex shader has completed, the triangles are passed to a rasterizer. The rasterizer determines which pixels are inside the triangles and generates a &quot;fragment&quot; for each one. These fragments are passed to the fragment shader, which decides their color.</p>
<p>One popular tool for experimenting with shaders is <a href="https://www.shadertoy.com/">Shadertoy</a>, a website that allows you to write, play with, and share shaders with minimal setup time. I highly recommend this route if you care primarily about making cool stuff quickly. I wanted to gain a deeper understanding of the underlying technologies and be able to embed my work into other applications, so I setup my own stack.</p>
<h3>My Stack</h3>
<p>I first attempted the purist approach of a C++ implementation using OpenGL through the GLFW3 and GLAD libraries. This is the most performant solution but comes with the downside of having to recompile the code each time I tweaked the shader. This could be solved using some kind of live reload functionality, but I decided it wasn't worth the time to try and solve. Additionally, it would be difficult to display the results on this website. My work in this direction is linked in the &quot;More Resources&quot; section below if you'd like to give it a try.</p>
<p>Instead I turned to the popular Javascript graphics library Three.js. Three has a boat load of awesome functionalities, including WebGL support. WebGL is, as you might have guessed, a browser based implementation of OpenGL, allowing me to render my shaders directly to a <code>&lt;canvas&gt;</code> element.</p>
<h3>Pixel Shaders</h3>
<p>A ray marching is a function called on each pixel of the display, so therefore we want a fragment corresponding to every location in the viewport. I achieved this by generating a plane of size (2, 2) and centering it on the x, y plane. I then applied a vertex shader that maps the real-world x-y coordinates of the planes mesh into viewport x-y coordinates. Because viewport coordinates range from -1 to 1, this causes the plane to cover the whole viewport, regardless of size. Here is the code for the plane and for the vertex shader:</p>
<p><em>insert code</em></p>
<p>Note that the vertex shader is independent of camera position, so the plane will cover the viewport no matter what. We can reintegrate the camera information into the fragment shader to allow use of Three's camera controls.</p>
<p><em>insert code</em></p>
<p>Here is the full code for a simple ray marched sphere with camera controls. As you can see, it's not as intimidating as the online literature often makes it seem:</p>
<p><em>insert code</em></p>
<p><em>insert demo</em></p>
<h2>Conclusion</h2>
<p>And that sums up my experiences learning about ray marching. This is neither the most rigorous nor in depth explanation of the techniques, but is meant as a way to promote interest in this powerful and elegant algorithm. I also got to show off some pretty visualizations along the way, which is always a plus. The following resources were invaluable to my learning, and are a great starting point for someone interested in developing their own code. Thanks for reading!</p>
<h2>More Resources</h2>
<p>All of the code for my ray marching setup + the code for these demos are on my github: <a href="https://github.com/usedhondacivic/ThreeJS-Raymarcher">https://github.com/usedhondacivic/ThreeJS-Raymarcher</a></p>
<p>Here is the code for my C++ ray marcher implementation: <a href="https://github.com/usedhondacivic/Cpp-raymarcher/blob/master/source/Main.cpp">https://github.com/usedhondacivic/Cpp-raymarcher/blob/master/source/Main.cpp</a></p>
<p>Inigo Quilez is the worlds foremost authority in ray marching and computer graphics as a whole. His website is one of the most impressive collections of work I have ever seen, and is a must read for anyone interested in math or programming. Find it here: <a href="https://iquilezles.org/">https://iquilezles.org/</a></p>
<p>I also enjoyed this tutorial from Jamie Wong, which builds into the concepts nicely: <a href="https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/">https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/</a></p>
<p>Learning GLSL has a bit of a steep learning curve, but this website helped a lot: <a href="https://learnopengl.com/Getting-started/Shaders">https://learnopengl.com/Getting-started/Shaders</a></p>
<p><em>insert reference for fractal distance field derivation</em></p>

    </article>
    <div id="right_pad"></div>
</body>

</html>